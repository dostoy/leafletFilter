/*
 * L.TimeDimension.Layer.VelocityLayer: TimeDimension for VelocityLayer
 */
Date.prototype.format = function(mask, utc) {
    return dateFormat(this, mask, utc);
};

/*
Vanilla JavaScript version of jQuery.extend()
https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
*/
var extend = function() {
    // Variables
    var extended = {};
    var deep = false;
    var i = 0;
    var length = arguments.length;

    // Check if a deep merge
    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
        deep = arguments[0];
        i++;
    }

    // Merge the object into the extended object
    var merge = function(obj) {
        for (var prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                // If deep merge and property is an object, merge properties
                if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                    extended[prop] = extend(true, extended[prop], obj[prop]);
                } else {
                    extended[prop] = obj[prop];
                }
            }
        }
    };

    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        var obj = arguments[i];
        merge(obj);
    }

    return extended;
};

L.TimeDimension.Layer.VelocityLayer = L.TimeDimension.Layer.extend({

    initialize: function(options) {
        var config = {
            displayValues: true,
            displayOptions: {
                velocityType: 'GBR Water',
                displayPosition: 'bottomleft',
                displayEmptyString: 'No currents data'
            },
            data: [],
            maxVelocity: 0.3,
            velocityScale: 0.1 // arbitrary default 0.005
        };

        config = extend(config, options.velocityLayerOptions || {});
        var layer = new L.velocityLayer(config);

        L.TimeDimension.Layer.prototype.initialize.call(this, layer, options);
        this._currentLoadedTime = 0;
        this._currentTimeData = [];
        this._baseURL = this.options.baseURL || null;
    },

    onAdd: function(map) {
        L.TimeDimension.Layer.prototype.onAdd.call(this, map);
        map.addLayer(this._baseLayer);
        if (this._timeDimension) {
            this._getDataForTime(this._timeDimension.getCurrentTime());
        }
    },

    _onNewTimeLoading: function(ev) {
        this._getDataForTime(ev.time);
        return;
    },

    isReady: function(time) {
        return (this._currentLoadedTime == time);
    },

    _update: function() {
        this._baseLayer.setData(this._currentTimeData);
        return true;
    },

    _getDataForTime: function(time) {
        if (!this._baseURL || !this._map) {
            return;
        }
        var url = this._constructQuery(time);
        var oReq = new XMLHttpRequest();
        oReq.addEventListener("load", (function(xhr) {
            var response = xhr.currentTarget.response;
            var data = JSON.parse(response);
            delete this._currentTimeData;
            this._currentTimeData = this._processLoadedData(data);
            this._currentLoadedTime = time;
            if (this._timeDimension && time == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading()) {
                this._update();
            }
            this.fire('timeload', {
                time: time
            });
        }).bind(this));

        oReq.open("GET", url);
        oReq.send();
    },

    _constructQuery: function(time) {
        var time = new Date(time);
        var timeParams = "&time=" +
            time.format('isoDateTime');
        var url = this._baseURL + timeParams;
        return url;
    },

    _processLoadedData: function(data) {
        return data;
    }
});

L.timeDimension.layer.velocityLayer = function(options) {
    return new L.TimeDimension.Layer.VelocityLayer(options);
};


L.TimeDimension.Layer.VelocityLayer.Radar = L.TimeDimension.Layer.VelocityLayer.extend({

    initialize: function(options) {
        options.baseURL = options.baseURL || "http://apitest.socib.es/data-sources/2653723fc6/data/?max_qc_value=3&standard_variable=northward_sea_water_velocity&standard_variable=eastward_sea_water_velocity&processing_level=L1&format=json";
        L.TimeDimension.Layer.VelocityLayer.prototype.initialize.call(this, options);
    },

    _constructQuery: function(time) {
        var startDate = new Date(time);
        var endDate = new Date(startDate.getTime());
        L.TimeDimension.Util.addTimeDuration(endDate, "PT30M", false);
        var timeParams = "&initial_datetime=" +
            startDate.format('yyyy-mm-dd\'T\'HH:MM:ss') +
            "&end_datetime=" +
            endDate.format('yyyy-mm-dd\'T\'HH:MM:ss');
        var url = this._baseURL + timeParams;
        this._proxy = 'server/proxy-apitest.php';
        if (this._proxy) {
            url = this._proxy + '?url=' + encodeURIComponent(url);
        }
        return url;
    },

    _processLoadedData: function(data) {
        var u = data.L1.features[0].variables.U;
        var v = data.L1.features[0].variables.V;
        var lat = data.L1.features[0].coordinates.latitude;
        var lon = data.L1.features[0].coordinates.longitude;
        var time = data.L1.features[0].coordinates.time.data[0];

        var u_header = {
            "parameterUnit": u.units,
            "parameterNumberName": u.standard_name,
            // "parameterNumber": 3, // northward-v
            "parameterNumber": 2, // eastward-u
            "parameterCategory": 2,
            "la1": lat.data[0],
            "la2": lat.data[lat.data.length - 1],
            "lo1": lon.data[0],
            "lo2": lon.data[lon.data.length - 1],
            "nx": lon.data.length,
            "ny": lat.data.length,
            "refTime": time
        };
        u_header['dx'] = (u_header['lo2'] - u_header['lo1']) / u_header['nx'];
        u_header['dy'] = (u_header['la1'] - u_header['la2']) / u_header['ny'];

        var v_header = {
            "parameterUnit": v.units,
            "parameterNumberName": v.standard_name,
            "parameterNumber": 3, // northward-v
            "parameterCategory": 2,
            "la1": lat.data[0],
            "la2": lat.data[lat.data.length - 1],
            "lo1": lon.data[0],
            "lo2": lon.data[lon.data.length - 1],
            "nx": lon.data.length,
            "ny": lat.data.length,
            "refTime": time
        };
        v_header['dx'] = (v_header['lo2'] - v_header['lo1']) / v_header['nx'];
        v_header['dy'] = (v_header['la1'] - v_header['la2']) / v_header['ny'];

        return [{
            "header": u_header,
            "data": _.flatten(u.data[0])
        }, {
            "header": v_header,
            "data": _.flatten(v.data[0])
        }, ];
    }
});

L.timeDimension.layer.velocityLayer.radar = function(options) {
    return new L.TimeDimension.Layer.VelocityLayer.Radar(options);
};