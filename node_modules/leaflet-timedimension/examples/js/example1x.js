L.TimeDimension.Layer.DrifterDeployment = L.TimeDimension.Layer.GeoJson.extend({

    initialize: function(layer, options) {
        layer = L.geoJson();
        L.TimeDimension.Layer.GeoJson.prototype.initialize.call(this, layer, options);
        this._id_platform = this.options.id_platform;
        this._id_deployment = this.options.id_deployment;
    },

    onAdd: function(map) {
        L.TimeDimension.Layer.prototype.onAdd.call(this, map);
        var proxy = "server/proxy-datadiscovery.php";
        var url = "http://apps.socib.es/DataDiscovery/deployment-info?" +
            "id_platform=" + this._id_platform + "&id_deployment=" + this._id_deployment +
            "&sample=50";
        $.getJSON(proxy + '?url=' + encodeURIComponent(url), (function(map, data) {
            this._baseLayer = this._createLayer(data);
            this._onReadyBaseLayer();
        }.bind(this, map)));
    },

    _createLayer: function(featurecollection) {
        // lastPosition
        this._color = this._pickRandomColor();


        this._icon = L.icon({
            iconUrl: 'img/surface-drifter.png',
            iconSize: [20, 20],
            iconAnchor: [10, 20]
        });

        var layer = L.geoJson(null, {
            pointToLayer: (function(feature, latLng) {
                if (feature.properties.hasOwnProperty('last')) {
                    return new L.Marker(latLng, {
                        icon: this._icon
                    });
                }
                return L.circleMarker(latLng, {
                    fillColor: this._color,
                    fillOpacity: 0.5,
                    stroke: false,
                    radius: 3
                });
            }).bind(this),
            style: (function(feature) {
                return {
                    "color": this._color,
                    "weight": 2,
                    "opacity": 1
                };
            }).bind(this)
        });
        if (!featurecollection.features) {
            return layer;
        }
        layer.addData(featurecollection.features[0]);
        for (var i = 1, l = featurecollection.features.length; i < l; i++) {
            var point = featurecollection.features[i];
            // fix Point
            if (point.geometry.type == 'point') {
                point.geometry.type = 'Point';
            }
            layer.addData(point);
        }
        // save last point
        this._lastPoint = featurecollection.features[featurecollection.features.length - 1];
        return layer;
    },

    _pickRandomColor: function() {
        var colors = ["#00aaff", "#ffaa00", "#ff00aa", "#ff0000", "#00ffaa", "#00ff00", "#0000ff", "#aa00ff", "#aaff00"];
        var index = Math.floor(Math.random() * colors.length);
        return colors[index];
    },

    _addDeploymentTrajectory: function(layer, trajectory_feature) {
        // remove the old one
        if (this._deploymentTrajectory) {
            layer.removeLayer(this._deploymentTrajectory);
        }
        var getStyle = (function(feature) {
            return {
                "color": this._color,
                "weight": 2,
                "opacity": 1
            };
        }).bind(this);
        var deploymentTrajectory = L.geoJson(trajectory_feature, {
            style: getStyle
        });
        // deploymentTrajectory.on('click', deployment.popupFunction.bind(this, deployment, undefined));
        deploymentTrajectory.addTo(layer);
        // save for later
        this._deploymentTrajectory = deploymentTrajectory;
    },

    _addDeploymenPoint: function(layer, point, isLastPoint) {
        var deploymentPoint = L.geoJson(point, {
            pointToLayer: (function(feature, latLng) {
                if (isLastPoint) {
                    return new L.Marker(latLng, {
                        icon: this._icon
                    });
                } else {
                    return L.circleMarker(latLng, {
                        fillColor: this._color,
                        fillOpacity: 0.5,
                        stroke: false,
                        radius: 3
                    });
                }
            }).bind(this)
        });
        // deploymentPoint.on('click', deployment.popupFunction.bind(this, deployment, point));
        deploymentPoint.addTo(layer);
        if (isLastPoint)
            this._lastPoint = deploymentPoint;
    }


});

L.timeDimension.layer.drifterDeployment = function(options) {
    return new L.TimeDimension.Layer.DrifterDeployment(null, options);
};


var map = L.map('map', {
    zoom: 8,
    center: [37.4, 1.20],
    fullscreenControl: true,
    timeDimensionControl: true,
    timeDimension: true,
    timeDimensionOptions: {
        timeInterval: "2009-01-01/2014-10-30",
        period: "PT6H",
        currentTime: Date.parse("2010-03-12T00:00:00Z")
    },
    timeDimensionControlOptions: {    
        playerOptions: {                        
            loop: true,
            transitionTime: 1500,
            buffer: 10
        }
    }
});

// Add OSM and emodnet bathymetry to map
var osmLayer = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
});
var bathymetryLayer = L.tileLayer.wms("http://admin.n4m5.eu/geoserver/wms", {
    layers: 'emodnet:mean_singlecolour',
    format: 'image/png',
    transparent: true,
    attribution: "Emodnet bathymetry",
    opacity: 0.3
});
var bathymetryLayer2 = L.tileLayer.wms("http://admin.n4m5.eu/geoserver/wms", {
    layers: 'emodnet:mean_singlecolour',
    format: 'image/png',
    transparent: true,
    attribution: "Emodnet bathymetry",
    opacity: 0.3
});

var osmBathymetry = L.layerGroup([osmLayer, bathymetryLayer2]);
osmBathymetry.addTo(map);
var baseMaps = {
    "Emodnet bathymetry": bathymetryLayer,
    "Emodnet bathymetry + OSM": osmBathymetry
};
var wmopWMS = "http://thredds.priv.socib.es/thredds/wms/operational_models/oceanographical/hydrodynamics/model_run_aggregation/wmopv2/wmopv2_best.ncd";
var wmopTemperatureLayer = L.tileLayer.wms(wmopWMS, {
    layers: 'temp',
    format: 'image/png',
    transparent: true,    
    abovemaxcolor: "extend",
    belowmincolor: "extend",
    numcolorbands: 40,
    styles: 'boxfill/sst_36',
    zIndex: 1,
});

var wmopTemperatureContourLayer = L.tileLayer.wms(wmopWMS, {
    layers: 'temp',
    format: 'image/png',
    transparent: true,    
    numcontours: 11,
    styles: 'contour/sst_36',
    zIndex: 10,
});

var wmopSalinityLayer = L.tileLayer.wms(wmopWMS, {
    layers: 'salt',
    format: 'image/png',
    transparent: true,    
    abovemaxcolor: "extend",
    belowmincolor: "extend",
    numcolorbands: 40,
    styles: 'boxfill/mpl_rdbu_r'
});

var wmopSalinityContourLayer = L.tileLayer.wms(wmopWMS, {
    layers: 'salt',
    format: 'image/png',
    transparent: true,    
    numcontours: 11,
    styles: 'contour/sst_36'
});

var wmopVelocityLayer = L.nonTiledLayer.wms(wmopWMS, {
    layers: 'sea_water_velocity',
    format: 'image/png',
    transparent: true,
    colorscalerange: '0,3',
    abovemaxcolor: "extend",
    belowmincolor: "extend",
    markerscale: 10,
    markerspacing: 8,
    styles: 'prettyvec/greyscale'    
});

var proxy = 'server/proxy.php';
var wmopVelocityTimeLayer = L.timeDimension.layer.wms(wmopVelocityLayer, {proxy: proxy, updateTimeDimension: false});
var overlayMaps = {
    "WMOP - Velocity": wmopVelocityTimeLayer
};

var layersControl = L.control.layers(baseMaps, overlayMaps);
layersControl.addTo(map);

wmopVelocityTimeLayer.addTo(map);

var getLayerMinMax = function(layer, callback) {
    var url = wmopWMS + '?service=WMS&version=1.1.1&request=GetMetadata&item=minmax';
    url = url + '&layers=' + layer.options.layers;    
    url = url + '&srs=EPSG:4326';    
    var size = map.getSize();
    url = url + '&BBox=' + map.getBounds().toBBoxString();
    url = url + '&height=' + size.y;
    url = url + '&width=' + size.x;
    url = proxy + '?url=' + encodeURIComponent(url);

    $.getJSON(url, (function(layer, data) {
        var range = data.max - data.min;
        var min = Math.floor(data.min) - 1;
        var max = Math.floor(data.max + 2);
        layer.options.colorscalerange = min + "," + max;
        layer.wmsParams.colorscalerange = min + "," + max;
        if (callback !== undefined) {
            callback();
        }
    }).bind(this, layer));
};

var addTimeDimensionLayer = function(layer, name, addToMap){
    var timeDimensionLayer = L.timeDimension.layer.wms(layer, {proxy: proxy});
    layersControl.addOverlay(timeDimensionLayer, name);
    if (addToMap)
        timeDimensionLayer.addTo(map);
}

getLayerMinMax(wmopTemperatureLayer, function(){
    addTimeDimensionLayer(wmopTemperatureLayer, 'WMOP - Temperature', true);
    wmopTemperatureContourLayer.wmsParams.colorscalerange = wmopTemperatureLayer.wmsParams.colorscalerange;
    wmopTemperatureContourLayer.options.colorscalerange = wmopTemperatureLayer.wmsParams.colorscalerange;
    addTimeDimensionLayer(wmopTemperatureContourLayer, 'WMOP - Temperature (Contour)', true);    
});
getLayerMinMax(wmopSalinityLayer, function(){
    addTimeDimensionLayer(wmopSalinityLayer, 'WMOP - Salinity', false);
    wmopSalinityContourLayer.wmsParams.colorscalerange = wmopSalinityLayer.wmsParams.colorscalerange;
    wmopSalinityContourLayer.options.colorscalerange = wmopSalinityLayer.wmsParams.colorscalerange;    
    addTimeDimensionLayer(wmopSalinityContourLayer, 'WMOP - Salinity (Contour)', false);
});

var turtles = [
    [265, 443],
    [260, 453],
    [264, 445],
    [263, 450],
    [226, 390],
];

for (var i = 0, l = turtles.length; i < l; i++) {
    var turtleLayer = L.timeDimension.layer.drifterDeployment({
        id_platform: turtles[i][0],
        id_deployment: turtles[i][1],
        duration: "P1W",
        addlastPoint: true
    });
    turtleLayer.addTo(map);
}